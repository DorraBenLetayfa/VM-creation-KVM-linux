---
# tasks file for vmcreation

- name: Set VM variables for this loop item
  set_fact:
    vm_name: "{{ item.vm_name }}"
    vm_memory: "{{ item.vm_memory }}"
    vm_vcpus: "{{ item.vm_vcpus }}"
    vm_disk_size: "{{ item.vm_disk_size }}"
    vm_os_variant: "{{ item.vm_os_variant }}"
    vm_disk_format: "{{ item.vm_disk_format }}"
    storage_path: "{{ item.storage_path }}/{{ item.vm_name }}.{{ item.vm_disk_format }}"
    vm_cloud_iso: "{{ item.vm_cloud_iso }}"
    vm_ip: "{{ item.vm_ip }}"
    vm_gateway: "{{ item.vm_gateway }}"
    vm_user: "{{ item.vm_user }}"
    vm_password: "{{ item.vm_password }}"

- name: Check if VM already exists
  community.libvirt.virt:
    name: "{{ vm_name }}"
    command: status
  register: vm_info
  become: true
  changed_when: false
  failed_when: false

- name: Debug VM info
  debug:
    var: vm_info
  when: vm_info.status is defined

- name: Stop if VM already exists
  fail:
    msg: "VM {{ vm_name }} already exists! Stopping playbook."
  when: vm_info.status is defined

- name: Check if VM directory exists
  ansible.builtin.stat:
    path: "{{ storage_path }}/{{ vm_name }}"
  register: vm_dir

- name: Debug directory existence
  ansible.builtin.debug:
    msg: "Directory exists: {{ vm_dir.stat.exists }}"

# - name: Stop if directory already exists
#   fail:
#     msg: "directory {{ storage_path }}/ {{  vm_name }} already exists! Stopping playbook."
#   when: vm_dir.stat.exists

- name: Remove VM directory if it exists
  ansible.builtin.file:
    path: "{{ storage_path }}/{{ vm_name }}"
    state: absent
  when: vm_dir.stat.exists

# Ensure VM folder exists
- name: Make VM directory
  file:
    path: "{{ storage_path }}/{{ vm_name }}"
    state: directory
    mode: '0755'
  become: true

# Download base cloud image if missing
- name: Download cloud image
  ansible.builtin.get_url:
    url: "{{ vm_cloud_iso }}" 
    dest: "{{ storage_path }}/{{ vm_name }}.qcow2"
    mode: '0644'
    force: no
  become: true

# Create VM disk from Fedora cloud image
- name: Create VM disk from base Fedora image
  ansible.builtin.command: >
    qemu-img create -f qcow2 -F qcow2 -b {{ storage_path }}/{{ vm_name }}.qcow2
    {{ storage_path }}/{{ vm_name }}/{{ vm_name }}.qcow2 {{ vm_disk_size }}G
  become: true
  args:
    creates: "{{ storage_path }}/{{ vm_name }}/{{ vm_name }}.qcow2"

# Prepare cloud-init ISO
- name: Prepare cloud-init files
  import_tasks: cloud_init.yml

# - name: Create disk image if it doesn't exist
#   community.libvirt.virt_volume:
#     name: "{{ vm_name }}.qcow2"
#     pool: "{{ pool }}"
#     state: present
#     xml: |
#       <volume>
#         <name>{{ vm_name }}.qcow2</name>
#         <capacity unit="G">{{ vm_disk_size }}</capacity>
#         <target>
#           <format type="{{ vm_disk_format }}"/>
#         </target>
#       </volume>
#   when: vm_info.status is not defined

- name: Generate libvirt XML configuration
  ansible.builtin.template:
    src: vm_template.xml.j2
    dest: "/tmp/{{ vm_name }}.xml"
  when: vm_info.status is not defined

- name: Define VM
  ansible.builtin.command: virsh -c qemu:///system define /tmp/{{ vm_name }}.xml
  become: true

- name: Start VM
  ansible.builtin.command: virsh -c qemu:///system  start {{ vm_name }}
  become: true

- name: Get VM info
  community.libvirt.virt:
    name: "{{ vm_name }}"
    command: status
  register: vm_info

- name: Start existing VM if it's not running
  community.libvirt.virt:
    name: "{{ vm_name }}"
    state: running
  when: vm_info.status is not defined and vm_result is defined

- name: Clean up temporary XML file
  ansible.builtin.file:
    path: "/tmp/{{ vm_name }}.xml"
    state: absent
  ignore_errors: true

- name: Show VM status
  ansible.builtin.debug:
    msg: "VM '{{ vm_name }}' is {{ vm_info.status }}"

# Clean up temporary XML file
- name: Remove temporary XML
  file:
    path: "/tmp/{{ vm_name }}.xml"
    state: absent
  ignore_errors: true
